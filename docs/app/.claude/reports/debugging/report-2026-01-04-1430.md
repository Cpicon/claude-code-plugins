# Debugging Report

**Date**: 2026-01-04 14:30
**Issue**: Users can register with the same email address multiple times

## Issue Summary
- **Reported Issue**: Email duplicate validation is not working properly - users can register with the same email address multiple times
- **Affected Components**: User registration endpoint (`POST /users`), email validation logic, in-memory user storage (`users_db`)
- **Severity**: **HIGH**

## Investigation Trail

| Agent Consulted | Findings | Evidence |
|-----------------|----------|----------|
| project-debugger (self) | Identified this as Pattern 3: Data Integrity Issue - duplicate records allowed | Known bugs documentation, line 78 in main.py |
| FastAPI expertise (documented patterns) | Email check loop has off-by-one error in range iteration | main.py:78 - `range(0, user_id_counter)` |
| Code analysis | User IDs start at 1 (incremented before storage), but range starts at 0 | main.py:86-95 - user_id_counter incremented then used as ID |

## Root Cause Analysis

- **Root Cause**: **Off-by-one error in email duplicate check loop** at `/Users/christianpiconcalderon/PycharmProjects/claude-code-plugins/docs/app/main.py:78`

- **Technical Explanation**:
  The email validation loop uses `range(0, user_id_counter)` which has two critical flaws:

  1. **Wrong starting point**: The range starts at `0`, but user IDs start at `1` (the counter is incremented at line 86 before being used as the ID at line 88)
  2. **Wrong ending point**: The range ends at `user_id_counter`, but should be `user_id_counter + 1` since:
     - When creating the first user, `user_id_counter` is `0`
     - After increment, it becomes `1` and that user is stored as `users_db[1]`
     - For the second user, `range(0, 1)` only checks ID `0` (which doesn't exist), missing the check for ID `1`

- **Contributing Factors**:
  - In-memory storage using dictionary with integer keys makes off-by-one errors non-obvious
  - Global counter incremented before use creates confusion about current vs. next ID
  - No unit tests to catch this edge case during development

- **Evidence Chain**:
  ```python
  # Line 78 - The buggy check
  for uid in range(0, user_id_counter):  # If counter is 1, this checks [0], missing user 1
      if uid in users_db and users_db[uid]["email"] == user.email:
          email_exists = True
          break

  # Line 86-95 - How users are actually stored
  user_id_counter += 1  # Counter becomes 1 for first user
  new_user = {
      "id": user_id_counter,  # ID is 1
      ...
  }
  users_db[user_id_counter] = new_user  # Stored at users_db[1]
  ```

- **Related Known Bugs**: This exactly matches the documented "Email Duplicate Check" bug in the project-debugger agent knowledge base at line 34.

## Impact Assessment

- **Direct Effects**:
  - Multiple users can register with identical email addresses
  - Data integrity violation - emails should be unique identifiers
  - Potential authentication confusion if email-based login is added
  - Privacy concerns - users might inadvertently access wrong accounts

- **Side Effects & Warnings**:
  - **Username validation works correctly** (lines 71-73) using `.values()` iteration
  - **First user with any email will NEVER be checked** - range never includes ID 1
  - Each subsequent user's email is only checked against users with IDs up to N-1
  - This creates a systematic gap where the most recent user's email is never validated
  - If user deletion is implemented with ID reuse, this could create even more edge cases

- **Risk Level**: **HIGH**
  - Core functionality failure (duplicate prevention)
  - Data integrity violation
  - No data loss or security breach, but foundation for future auth problems

- **Users Affected**:
  - All users attempting to register (100% of registration flow)
  - Particularly problematic if users retry failed registrations

## Solutions (Ordered by Effort)

### 1. Quick Fix (Low Effort)
- **Change**: Fix the range to correctly iterate over existing user IDs
- **Files**: `/Users/christianpiconcalderon/PycharmProjects/claude-code-plugins/docs/app/main.py:78`
- **Code Change**:
  ```python
  # Change FROM:
  for uid in range(0, user_id_counter):

  # Change TO:
  for uid in range(1, user_id_counter + 1):
  ```
- **Trade-offs**:
  - Still uses inefficient loop instead of direct lookup
  - Doesn't address the confusing counter increment pattern
  - O(n) complexity for what should be O(1) operation

### 2. Proper Fix (Medium Effort)
- **Change**: Use the same pattern as username validation - iterate over `.values()`
- **Files**: `/Users/christianpiconcalderon/PycharmProjects/claude-code-plugins/docs/app/main.py:75-84`
- **Code Change**:
  ```python
  # Replace lines 75-84 with:
  # Check if email already exists
  for existing_user in users_db.values():
      if existing_user["email"] == user.email:
          raise HTTPException(status_code=400, detail="Email already registered")
  ```
- **Benefits**:
  - Matches existing username validation pattern (consistency)
  - No off-by-one errors possible
  - More readable and maintainable
  - Still O(n) but correct implementation

### 3. Comprehensive Fix (High Effort)
- **Change**: Add email index for O(1) lookups, refactor storage architecture
- **Files**:
  - `/Users/christianpiconcalderon/PycharmProjects/claude-code-plugins/docs/app/main.py:17-18` (add email index)
  - `/Users/christianpiconcalderon/PycharmProjects/claude-code-plugins/docs/app/main.py:75-84` (use index for lookup)
  - `/Users/christianpiconcalderon/PycharmProjects/claude-code-plugins/docs/app/main.py:162-173` (update index on delete)
- **Code Changes**:
  ```python
  # At line 18, add:
  emails_index: dict[str, int] = {}  # email -> user_id mapping

  # At lines 75-84, replace with:
  if user.email in emails_index:
      raise HTTPException(status_code=400, detail="Email already registered")

  # At line 95, after storing user:
  emails_index[user.email] = user_id_counter

  # At line 171, in delete_user:
  del emails_index[user["email"]]
  ```
- **Long-term Benefits**:
  - O(1) email lookup performance
  - Scalable architecture for large user bases
  - Foundation for email-based features (password reset, email login)
  - Clear separation of concerns (indexed access patterns)

## Verification Steps

### For Quick Fix or Proper Fix:
1. **Manual Testing**:
   ```bash
   # Start the server
   uvicorn main:app --reload

   # In another terminal, create first user
   curl -X POST http://localhost:8000/users \
     -H "Content-Type: application/json" \
     -d '{"username":"user1","email":"test@example.com","password":"pass123"}'

   # Try to create second user with same email (should fail with 400)
   curl -X POST http://localhost:8000/users \
     -H "Content-Type: application/json" \
     -d '{"username":"user2","email":"test@example.com","password":"pass456"}'

   # Expected: {"detail":"Email already registered"}
   ```

2. **Unit Test to Add** (create in `tests/test_user_creation.py`):
   ```python
   def test_duplicate_email_rejected():
       """Verify that duplicate email addresses are rejected."""
       # Create first user
       response1 = client.post("/users", json={
           "username": "user1",
           "email": "test@example.com",
           "password": "password123"
       })
       assert response1.status_code == 200

       # Attempt to create second user with same email
       response2 = client.post("/users", json={
           "username": "user2",
           "email": "test@example.com",
           "password": "password456"
       })
       assert response2.status_code == 400
       assert "Email already registered" in response2.json()["detail"]
   ```

3. **Edge Case Testing**:
   - Test with first user created (previously never validated)
   - Test with multiple users already in system
   - Test with mixed case emails (test@example.com vs TEST@EXAMPLE.COM)
   - Test after user deletion (if soft delete doesn't free up email)

### For Comprehensive Fix:
Additional verification for index consistency:
```python
def test_email_index_consistency():
    """Verify email index stays in sync with users_db."""
    # After each user creation/deletion
    assert len(emails_index) == len([u for u in users_db.values() if u["is_active"]])
    for email, uid in emails_index.items():
        assert users_db[uid]["email"] == email
```

## Agents Used
- **Primary Investigator**: project-debugger (self)
- **Supporting Agents**: None required - issue matched documented known bug
- **Specialist Knowledge Applied**:
  - FastAPI expert patterns (username validation comparison)
  - Architecture expert principles (index-based lookups)
- **Unused Agents**:
  - user-api-security-expert (not an auth/security issue)
  - user-api-testing-expert (no test failures to investigate, tests need to be created)

## Additional Notes

### Why This Bug Is Subtle
The bug is particularly insidious because:
1. The code "looks" like it should work - it has a validation loop
2. The check succeeds for most users (except checking against the most recent user)
3. Username validation works correctly using a different pattern
4. Without tests, this only appears during manual testing or production use

### Recommended Next Steps
1. Apply **Proper Fix** (Solution 2) for immediate correctness
2. Add unit tests for duplicate email validation
3. Consider **Comprehensive Fix** (Solution 3) as part of larger refactoring
4. Add integration tests for all validation scenarios
5. Review other validation loops for similar off-by-one patterns

### Cross-Reference with Other Bugs
This is 1 of 4 documented bugs in this codebase:
- âœ“ **Email Duplicate (this report)** - Line 78 - HIGH severity
- Session Expiration - Line 124 - MEDIUM severity
- Soft Delete - Lines 169-172 - MEDIUM severity
- Password Hashing - Lines 42-44 - CRITICAL severity (security)

The email validation bug should be fixed alongside the soft delete bug, as deleted users should free up their email addresses for re-registration.
